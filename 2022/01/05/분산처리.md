# 분산처리
https://www.acmicpc.net/problem/1009

처음에는 너무 단순하게 생각해서, 제곱수를 구하고 10으로 나눈 나머지를 구하는 방식으로 접근하였습니다.

하지만, 이내 7^100이나, 9^635 같은 무지막지하게 큰 제곱수를 구하는 것 자체가 오버헤드가 크다는 것을 깨닫게 되었습니다.

그래서 다른 방법을 찾아보다가, 제곱수의 `1의 자리가 일정한 패턴으로 반복`된다는 것을 알게되어 문제를 해결할 수 있었습니다.

----

# 풀이

```java
import java.util.Scanner;

public class Main {

    private final int[][] POW_REPEATS =
            {
                    {1},       // 1제곱의 1의 자리 반복
                    {2,4,8,6}, // 2제곱의 1의 자리 반복
                    {3,9,7,1}, // 3제곱의 1의 자리 반복
                    {4,6},     // 4제곱의 1의 자리 반복
                    {5},       // 5제곱의 1의 자리 반복
                    {6},       // 6제곱의 1의 자리 반복
                    {7,9,3,1}, // 7제곱의 1의 자리 반복
                    {8,4,2,6}, // 8제곱의 1의 자리 반복
                    {9,1},     // 9제곱의 1의 자리 반복
                    {10}       // 10제곱의 1의 자리 반복
            };

    public static void main(String[] args) {
        Main main = new Main();
        main.solution();
    }

    private void solution() {
        int[][] allTestCases = getAllTestCases();
        int[] answers = new int[allTestCases.length];

        for (int y = 0; y < allTestCases.length; y++) {
            int number = allTestCases[y][0]; // 수
            int indices = allTestCases[y][1]; // 지수

            int digitOfOne = getDigitOfOne(number); // 1의 자리 수

            if (isSingleRepeat(digitOfOne)) {
                answers[y] = digitOfOne;
                continue;
            }
            
            if (indices == 1) {
                answers[y] = digitOfOne;
                continue;
            }

            answers[y] = getPowDigitOfOne(digitOfOne, indices);
        }

        // 결과 출력
        for (int answer : answers) {
            System.out.println(answer);
        }
    }

    private int[][] getAllTestCases() {
        Scanner sc = new Scanner(System.in);

        int caseLength = sc.nextInt();

        int[][] testCases = new int[caseLength][2];

        for (int y = 0; y < testCases.length; y++) {
            for (int x = 0; x < testCases[0].length; x++) {
                testCases[y][x] = sc.nextInt();
            }
        }

        return testCases;
    }

    private int getDigitOfOne(int number) {
        int digit = number;

        if (number > 10) {
            digit = number % 10;
            
            if (digit == 0) {
                digit = 10;
            }
        }

        return digit;
    }

    private boolean isSingleRepeat(int digit) {
        return digit == 1 || digit == 5 || digit == 6 || digit == 10;
    }

    private int getPowDigitOfOne(int digitOfOne, int indices) {
        int[] repeat = POW_REPEATS[digitOfOne-1];
        int repeatIndex = (indices % repeat.length) - 1;

        if (repeatIndex == -1) repeatIndex = repeat.length - 1;

        return repeat[repeatIndex];
    }
}
```

----

# 결과

![image](https://user-images.githubusercontent.com/45728407/148154398-11ed3abd-d5b2-481c-8d64-d9cfcd31f238.png)
