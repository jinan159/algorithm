# 단지번호붙이기
https://github.com/jinan159/algorithm/new/main/2021/12/02

연관 풀이(BFS) : https://github.com/jinan159/algorithm/blob/main/2021/11/24/단지번호붙이기.md

이 문제는 한번 BFS로 풀어본 문제인데, DFS로도 다시 한번 풀어봤다.

사실 BFS와 DFS의 구현방식은, 큐를 이용하느냐 스택을 이용하느냐의 차이 뿐이다.

하지만 그동안 문제를 풀면서 최대한 메소드를 분리해서 indent의 깊이를 최대한 줄이려고 노력했다.

시간이 지난 후 이전 소스와 현재 소스를 비교해 보니 확실히 더 읽기 좋은 소스가 되었다고 느낀다.

----

# 풀이

```java
import java.util.*;
import java.awt.Point;

public class Main {
    private static final int EMPTY = 0;
    private static final int HOUSE = 1;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int size = sc.nextInt();

        int[][] map = new int[size][size];

        for (int y=0; y<size; y++) {
            char[] row = sc.next().toCharArray();
            for (int x=0; x<row.length; x++) {
                map[y][x] = Integer.parseInt(Character.toString(row[x]));
            }
        }

        List<Integer> houseCounts = new LinkedList<>();

        for (int y=0; y<size; y++) {
            for (int x=0; x<size; x++) {
                if (map[y][x] == EMPTY) continue;
                houseCounts.add(getHouseCount(map, new Point(x, y)));
            }
        }
        
        Collections.sort(houseCounts);

        System.out.println(houseCounts.size());
        for (int count : houseCounts) {
            System.out.println(count);
        }

    }

    private static int getHouseCount(int[][] map, Point startPoint) {
        int houseCount = 0;
        int[] dirX = {1,-1,0,0};
        int[] dirY = {0,0,1,-1};

        Stack<Point> stack = new Stack<>();
        boolean[][] visit = new boolean[map.length][map[0].length];

        stack.push(startPoint);
        visit[startPoint.y][startPoint.x] = true;
        map[startPoint.y][startPoint.x] = EMPTY;
        houseCount++;

        while(!stack.isEmpty()) {
            Point current = stack.pop();

            for (int i=0; i<4; i++) {
                int nx = current.x + dirX[i];
                int ny = current.y + dirY[i];

                if (ny < 0 || ny >= map.length || nx < 0 || nx >= map[0].length) continue;
                if (map[ny][nx] == EMPTY || visit[ny][nx] == true) continue;

                stack.push(new Point(nx, ny));
                visit[ny][nx] = true;
                map[ny][nx] = EMPTY;

                houseCount++;
            }
        }

        return houseCount;
    }
}
```

----

# 결과

![image](https://user-images.githubusercontent.com/45728407/144534925-19c8b3de-105b-4ab0-b1b1-881146f1522b.png)
